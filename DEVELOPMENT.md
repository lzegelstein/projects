Week 1 (April 9- 16):
Our group has been struggling to get a solid proposal and throughout the week we have been working on the proposal. On Wednesday, we met with Professor Evans and discussed our first proposal. We decided to scrap the first proposal and create a new one on Thursday and Friday. Our new proposal had several issues brought up by Professor Evans and we found that the project would be not be plausible due to lack of data. On Friday night and Saturday, we created a new proposal that is more straightforward and detailed. In conclusion, this week have been gaining a more solid understanding of what this project entails and how we should approach the project. 

Week 2 (April 17 - 23):
We were able to import the data, perform data cleaning through our code itself, and load it into a class we constructed called AirTravel. In this class, we assigned nodes as Airports, containing IATA 3-letter codes. Each of these nodes have a vector of destinations, which we populated by cleaning and importing routes data. Finally, our output creates a map of every Airport 3-letter code mapping onto the specific Airport Node. We also attempted to implement a DFS algorithm, however this was unsuccessful in performing a node traversal. 

Week 3 (April 24 - May 1):
In this week Dijkstra's was started and DFS was finished. We also did some major code organization. We came to the realization we were defeating the purpose of object oriented code by putting everything in the AirTravel class. In the reorganization we remove the Airport struct from the AirTravel class and made many things private member variables in AirTravel, includind the map for Airport* with IATA code keys. This organization allowed us to expand on our project much easier as our code became readable. 

Week 4 (May 2 - May 8):
During this week, Dijkstras was completed. It turned out to be significantly harder than we imagined because we were approaching it wrong from the begining. After re-watching the 4/26 lecture, we decided to model Dijkstras exactly as seen in lecture and it worked. The solution was to create 2 structs, one to keep track of the Path and another one to keep track of each vertex (AirportNode). The Path struct kept track of where each edge starts, ends, and the respective edge weight. The AirportNode struct keeps track of whether the vertex was visited or not, the total weight, and the airport that is represented by the vertex. Trying to stay as close to the in class example as possible, a new testing file was made with less airports and made up latitudes and longitudes found by the distance formula to model vertices and edge weights A through H from the example. 

Week 5 (May 8 - 12):
During the final week, we finished creating our visual graph and test cases for all our algorithms. We debugged any issues that occured and wrapped up our project. Some issues included debugging when moving from our shorter test dataset to the full dataset. Lots of git knowledge was gained during this time as we resolved a tremendous amount of merge conflicts.  After we finished coding, we wrote our report and created the video. 
